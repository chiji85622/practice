/**
 * 希尔排序(Shell Sort)
 * 第一个突破O(n2)的排序算法，是简单插入排序的改进版。
 * 它与插入排序的不同之处在于，它会优先比较距离较远的
 * 元素。希尔排序又叫缩小增量排序。
 * 
 * 先将整个待排序的记录序列分割成为若干子序列分别进行
 * 直接插入排序，
 * 算法描述
 *  1.选择一个增量序列t1，t2，…，tk，其中ti>tj，tk=1；
 *  2.按增量序列个数k，对序列进行k 趟排序；
 *  3.每趟排序，根据对应的增量ti，将待排序列分割成若干
 *    长度为m 的子序列，分别对各子表进行直接插入排序。
 *    仅增量因子为1 时，整个序列作为一个表来处理，表长
 *    度即为整个序列的长度。
 * 
 * 性能测试
 * 
 * 插入排序相同数量的随机数据排序的时间复杂度
    √ 第1次,随机数组长度为：1000 (371ms)
    √ 第2次,随机数组长度为：1000 (299ms)
    √ 第3次,随机数组长度为：1000 (316ms)
    ┌─────────┬──────┬─────────┬──────────┐
    │ (index) │ size │ compare │ exchange │
    ├─────────┼──────┼─────────┼──────────┤
    │    0    │ 1000 │ 258091  │  258091  │
    │    1    │ 1000 │ 252101  │  252101  │
    │    2    │ 1000 │ 257306  │  257306  │
    └─────────┴──────┴─────────┴──────────┘

 * 插入排序不同数量的随机数据排序的时间复杂度
    √ 第1次,随机数组长度为：1000 (315ms)
    √ 第2次,随机数组长度为：2000 (1376ms)
    √ 第3次,随机数组长度为：3000 (3097ms)
    ┌─────────┬──────┬─────────┬──────────┐
    │ (index) │ size │ compare │ exchange │
    ├─────────┼──────┼─────────┼──────────┤
    │    0    │ 1000 │ 250185  │  250185  │
    │    1    │ 2000 │ 997278  │  997278  │
    │    2    │ 3000 │ 2209303 │ 2209303  │
    └─────────┴──────┴─────────┴──────────┘
 */

/**
 * 希尔排序
 * @param {Array} arr
 * @param {Function} commpare
 * @param {Function} exchange
 * @return {Array}
 */
const sort = function(arr, compare, exchange) {
  const len = arr.length;
  let temp,
    gap = 1;

  //不同的gap取值
  // gap = Math.floor(len / 3);

  // for (; gap > 0; gap--) {
  //   for (let i = 0; i < len; i += gap) {
  //     let current = arr[i];
  //     let proIndex = i + gap;
  //     while (compare() && proIndex < len && arr[proIndex] < current) {
  //       exchange();
  //       arr[proIndex - gap] = arr[proIndex];
  //       proIndex += gap;
  //     }
  //     exchange();
  //     arr[proIndex - gap] = current;
  //   }
  // }

  // 我的写法
  while (gap < len / 3) {
    gap = gap * 3 + 1;
  }

  // while (gap >= 1) {
  //   for (let i = gap; i < len; i += gap) {
  //     let current = arr[i];
  //     let preIndex = i - gap;

  //     while (compare() && preIndex >= 0 && arr[preIndex] > current) {
  //       exchange()
  //       arr[preIndex + gap] = arr[preIndex];
  //       preIndex -= gap;
  //     }
  //     exchange()
  //     arr[preIndex + gap] = current;
  //   }
  //   // gap = Math.floor(gap / 3);
  //   gap--
  // }

  //书上的写法
  while (gap >= 1) {
    for (let i = gap; i < len; i++) {
      for (let j = i; compare() && j >= gap && arr[j] < arr[j - gap]; j -= gap) {
        exchange();
        [arr[j], arr[j - gap]] = [arr[j - gap], arr[j]];
      }
    }
    gap = Math.floor(gap / 3);
    // gap--
  }

  return arr;
};

export default sort;
// let a = [3, 2, 1, 6, 5, 4, 99,1,2,6,65,5, 11, 22, 55, 42];

// function compare(a, b) {
//   return a > b;
// }

// function exchange(arr, i, j) {
//   [arr[i], arr[j]] = [arr[j], arr[i]];
// }

// sort(a,compare,exchange)
// sort(a,()=>true,()=>true);

// console.log(a);

// 我自己的写法
// 希尔排序相同数量的随机数据排序的时间复杂度
// √ 第1次,随机数组长度为：1000 (307ms)
// √ 第2次,随机数组长度为：1000 (234ms)
// √ 第3次,随机数组长度为：1000 (281ms)
// 希尔排序不同数量的随机数据排序的时间复杂度
// √ 第1次,随机数组长度为：1000 (236ms)
// √ 第2次,随机数组长度为：2000 (1011ms)
// √ 第3次,随机数组长度为：3000 (2449ms)

// console.log console.js:328
// ┌─────────┬──────┬─────────┬──────────┐
// │ (index) │ size │ compare │ exchange │
// ├─────────┼──────┼─────────┼──────────┤
// │    0    │ 1000 │ 214728  │  214728  │
// │    1    │ 1000 │ 200790  │  200790  │
// │    2    │ 1000 │ 213864  │  213864  │
// └─────────┴──────┴─────────┴──────────┘

// console.log console.js:328
// ┌─────────┬──────┬─────────┬──────────┐
// │ (index) │ size │ compare │ exchange │
// ├─────────┼──────┼─────────┼──────────┤
// │    0    │ 1000 │ 203849  │  203849  │
// │    1    │ 2000 │ 819077  │  819077  │
// │    2    │ 3000 │ 1802535 │ 1802535  │
// └─────────┴──────┴─────────┴──────────┘

// 书上写法
// 希尔排序相同数量的随机数据排序的时间复杂度
// √ 第1次,随机数组长度为：1000 (34ms)
// √ 第2次,随机数组长度为：1000 (23ms)
// √ 第3次,随机数组长度为：1000 (16ms)
// 希尔排序不同数量的随机数据排序的时间复杂度
// √ 第1次,随机数组长度为：1000 (15ms)
// √ 第2次,随机数组长度为：2000 (37ms)
// √ 第3次,随机数组长度为：3000 (64ms)

// console.log console.js:328
// ┌─────────┬──────┬─────────┬──────────┐
// │ (index) │ size │ compare │ exchange │
// ├─────────┼──────┼─────────┼──────────┤
// │    0    │ 1000 │  15318  │   9861   │
// │    1    │ 1000 │  13865  │   8408   │
// │    2    │ 1000 │  14405  │   8948   │
// └─────────┴──────┴─────────┴──────────┘

// console.log console.js:328
// ┌─────────┬──────┬─────────┬──────────┐
// │ (index) │ size │ compare │ exchange │
// ├─────────┼──────┼─────────┼──────────┤
// │    0    │ 1000 │  14352  │   8895   │
// │    1    │ 2000 │  32764  │  20400   │
// │    2    │ 3000 │  55792  │  36428   │
// └─────────┴──────┴─────────┴──────────┘

// 不同gap
// 希尔排序相同数量的随机数据排序的时间复杂度
//     √ 第1次,随机数组长度为：1000 (112ms)
//     √ 第2次,随机数组长度为：1000 (83ms)
//     √ 第3次,随机数组长度为：1000 (82ms)
//   希尔排序不同数量的随机数据排序的时间复杂度
//     √ 第1次,随机数组长度为：1000 (114ms)
//     √ 第2次,随机数组长度为：2000 (354ms)
//     √ 第3次,随机数组长度为：3000 (623ms)

//   console.log console.js:328
//     ┌─────────┬──────┬─────────┬──────────┐
//     │ (index) │ size │ compare │ exchange │
//     ├─────────┼──────┼─────────┼──────────┤
//     │    0    │ 1000 │  83728  │  83728   │
//     │    1    │ 1000 │  73152  │  73152   │
//     │    2    │ 1000 │  73957  │  73957   │
//     └─────────┴──────┴─────────┴──────────┘

//   console.log console.js:328
//     ┌─────────┬──────┬─────────┬──────────┐
//     │ (index) │ size │ compare │ exchange │
//     ├─────────┼──────┼─────────┼──────────┤
//     │    0    │ 1000 │  75115  │  75115   │
//     │    1    │ 2000 │ 264175  │  264175  │
//     │    2    │ 3000 │ 510823  │  510823  │
//     └─────────┴──────┴─────────┴──────────┘
/**
 * 插入排序(Insertion Sort)
 * 是一种简单直观的排序算法。它的工作原理是通过构建有
 * 序序列，对于未排序数据，在已排序序列中从后向前扫描，
 * 找到相应位置并插入。
 * 
 * 算法描述
 *  1.从第一个元素开始，该元素可以认为已经被排序；
 *  2.取出下一个元素，在已经排序的元素序列中从后向前扫描；
 *  3.如果该元素（已排序）大于新元素，将该元素移到下一位置；
 *  4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
 *  5.将新元素插入到该位置后；
 *  6.重复步骤2~5。
 * 
 * 性能测试
 * 
 * 插入排序相同数量的随机数据排序的时间复杂度
    √ 第1次,随机数组长度为：1000 (371ms)
    √ 第2次,随机数组长度为：1000 (299ms)
    √ 第3次,随机数组长度为：1000 (316ms)
    ┌─────────┬──────┬─────────┬──────────┐
    │ (index) │ size │ compare │ exchange │
    ├─────────┼──────┼─────────┼──────────┤
    │    0    │ 1000 │ 258091  │  258091  │
    │    1    │ 1000 │ 252101  │  252101  │
    │    2    │ 1000 │ 257306  │  257306  │
    └─────────┴──────┴─────────┴──────────┘

 * 插入排序不同数量的随机数据排序的时间复杂度
    √ 第1次,随机数组长度为：1000 (315ms)
    √ 第2次,随机数组长度为：2000 (1376ms)
    √ 第3次,随机数组长度为：3000 (3097ms)
    ┌─────────┬──────┬─────────┬──────────┐
    │ (index) │ size │ compare │ exchange │
    ├─────────┼──────┼─────────┼──────────┤
    │    0    │ 1000 │ 250185  │  250185  │
    │    1    │ 2000 │ 997278  │  997278  │
    │    2    │ 3000 │ 2209303 │ 2209303  │
    └─────────┴──────┴─────────┴──────────┘
 */

/**
 * 插入排序
 * @param {Array} arr
 * @param {Function} commpare
 * @param {Function} exchange
 * @return {Array}
 */
const insertionSort = function(arr, compare, exchange) {
	const len = arr.length;

	for (let i = 1; i < len; i++) {
		for (let j = i; j >= 0 && arr[j] < arr[j - 1]; j--) {
			[ arr[j], arr[j - 1] ] = [ arr[j - 1], arr[j] ];
		}
	}

	return arr;
};

export default insertionSort;
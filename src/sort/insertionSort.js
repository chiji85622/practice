/**
 * 插入排序(Insertion Sort)
 * 是一种简单直观的排序算法。它的工作原理是通过构建有
 * 序序列，对于未排序数据，在已排序序列中从后向前扫描，
 * 找到相应位置并插入。
 * 
 * 算法描述
 *  1.从第一个元素开始，该元素可以认为已经被排序；
 *  2.取出下一个元素，在已经排序的元素序列中从后向前扫描；
 *  3.如果该元素（已排序）大于新元素，将该元素移到下一位置；
 *  4.重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；
 *  5.将新元素插入到该位置后；
 *  6.重复步骤2~5。
 * 
 * 性能测试
 * 
 * 插入排序相同数量的随机数据排序的时间复杂度
    √ 第1次,随机数组长度为：1000 (371ms)
    √ 第2次,随机数组长度为：1000 (299ms)
    √ 第3次,随机数组长度为：1000 (316ms)
    ┌─────────┬──────┬─────────┬──────────┐
    │ (index) │ size │ compare │ exchange │
    ├─────────┼──────┼─────────┼──────────┤
    │    0    │ 1000 │ 258091  │  258091  │
    │    1    │ 1000 │ 252101  │  252101  │
    │    2    │ 1000 │ 257306  │  257306  │
    └─────────┴──────┴─────────┴──────────┘

 * 插入排序不同数量的随机数据排序的时间复杂度
    √ 第1次,随机数组长度为：1000 (315ms)
    √ 第2次,随机数组长度为：2000 (1376ms)
    √ 第3次,随机数组长度为：3000 (3097ms)
    ┌─────────┬──────┬─────────┬──────────┐
    │ (index) │ size │ compare │ exchange │
    ├─────────┼──────┼─────────┼──────────┤
    │    0    │ 1000 │ 250185  │  250185  │
    │    1    │ 2000 │ 997278  │  997278  │
    │    2    │ 3000 │ 2209303 │ 2209303  │
    └─────────┴──────┴─────────┴──────────┘
 */

/**
 * 插入排序
 * @param {Array} arr
 * @param {Function} commpare
 * @param {Function} exchange
 * @return {Array}
 */
const insertionSort = function(arr, compare, exchange) {
  const len = arr.length;

  let preIndex,// 有序区序号，从后向前扫描
   current;// 待插入元素

  for (let i = 1; i < len; i++) {
    // 待插入元素
    current = arr[i];
    // 有序区组的最大序号
    preIndex = i - 1;

    // 有序数区，序号大于等于0 且 当前有序区元素比待插入元素大，
    // 则该有序区元素后移，有序区序号前移动
    while (compare() && preIndex >= 0 && arr[preIndex] > current) {
      exchange();
      arr[preIndex + 1] = arr[preIndex];
      preIndex--;
    }

    // 将待插入元素插入到有序区的位置
    exchange();
    arr[preIndex + 1] = current;
  }

  return arr;
};

export default insertionSort;
